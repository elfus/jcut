#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily \small},columns=fullflexible"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
JIT-TESTING Tutorial
\begin_inset CommandInset label
LatexCommand label
name "JIT-TESTING-Tutorial"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
What is it? 
\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 is a simple command line tool to perform 
\emph on
unit testing in C code
\emph default
 using the LLVM Just In Time (JIT) engine and some of the Clang APIs.
\end_layout

\begin_layout Subsection
Objectives 
\end_layout

\begin_layout Standard
The main objectives behind the design and implementation of this tool are:
 
\end_layout

\begin_layout Itemize
Minimize the amount of test code you need to write for your software written
 in C.
 
\end_layout

\begin_layout Itemize
Simplify the test code you write.
 
\end_layout

\begin_deeper
\begin_layout Itemize
We believe that writing a test for a function should be as simple as if
 you were calling that function with its parameters somewhere else in your
 program.
\end_layout

\end_deeper
\begin_layout Itemize
Minimize the compile times for your tests and in turn for your program.
 
\end_layout

\begin_deeper
\begin_layout Itemize
The jit-testing tool will actually compile only the functions you are testing,
 leaving the rest untouched.
 
\end_layout

\end_deeper
\begin_layout Itemize
Encourage Test Driven Development (TDD) and unit testing among C programmers.
\end_layout

\begin_layout Standard
While the main focus of our tool has always been oriented to unit testing
 and TDD we have found during the early stages of development and testing
 that this tool might be a good resource for educational purposes for C
 novice programmers and universities.
\end_layout

\begin_layout Subsection
How does it work? 
\end_layout

\begin_layout Standard

\emph on
jit-testing 
\emph default
takes as input 2 important things: your C source code and a test file.
\end_layout

\begin_layout Itemize

\emph on
C source code
\emph default
: jit-testing makes use of the Clang APIs to analyze and process the source
 code, hence it will behave pretty much like a compiler.
 It will analyze your C code and report any error if it exists.
 Then it will analyze your test file to know what tests you want to test.
 If you use a 3rd party library see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Testing-code-which"

\end_inset

 or 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:3rd-party-libraries."

\end_inset

.
\end_layout

\begin_layout Itemize

\emph on
Test file
\emph default
: This is a plain text file with any extension.
 In order for this tool to understand what you want to test and expecting
 from a test you need to use the 
\emph on
Jit-Testing Language
\emph default
.
 Don't worry about learning a new language, you will see in the rest of
 this tutorial that this language is really small, simple and based on a
 small subset of the C syntax.
 If you are comfortable with C's syntax then you're pretty much done learning
 this new language.
\end_layout

\begin_layout Standard
Upon receiving these 2 inputs the tool will analyze the C code using Clang
 APIs and will generate code for only those functions described in the test
 file and then run them using the LLVM JIT Execution Engine.
 Then a small report will be provided by the tool about the tests ran.
\end_layout

\begin_layout Standard
From a high level perspective the following diagram describes how JIT-TESTING
 works.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename jit-testing high level.jpg
	scale 40

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
High level view of how jit-testing works
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

 you can check what are the current limitations of this tool.
\end_layout

\begin_layout Subsection

\emph on
jit-testing 
\emph default
output
\begin_inset CommandInset label
LatexCommand label
name "sub:jit-testing-output"

\end_inset


\end_layout

\begin_layout Standard
In this section we will briefly explain how the output looks like and what
 it means.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
\paragraph_spacing single

================================================================================
======
\end_layout

\begin_layout Plain Layout

GROUP NAME | TEST NAME | FUNCTION CALLED | RESULT | ACTUAL RESULT | EXPECTED
 RESULT |
\end_layout

\begin_layout Plain Layout

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~
\end_layout

\begin_layout Plain Layout

 xxxxxxxxx | xxxxxxxxx | xxxxxxxxxxxxxxx | xxxxxx | xxxxxxxxxxxxx | xxxxxxxxxxxx
xxx |  
\end_layout

\begin_layout Plain Layout

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~
\end_layout

\begin_layout Plain Layout

TEST SUMMARY 
\end_layout

\begin_layout Plain Layout

Tests ran: 1 
\end_layout

\begin_layout Plain Layout

Tests PASSED: 1 
\end_layout

\begin_layout Plain Layout

Tests FAILED: 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The columns shown are explained from left to right:
\end_layout

\begin_layout Itemize
GROUP NAME: By default a group name is assigned to each test.
 As you will see in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Grouping-related-tests"

\end_inset

 you can create your own groups.
\end_layout

\begin_layout Itemize
TEST NAME: This name generated automatically by the tool based on the function
 under test.
\end_layout

\begin_layout Itemize
FUNCTION CALLED: This is the function under test and it will show the parameters
 used.
\end_layout

\begin_layout Itemize
RESULT: Whether the test has failed or passed.
\end_layout

\begin_layout Itemize
ACTUAL RESULT: If the function under test results a value it will be shown
 here whatever data type, otherwise it will show just void.
\end_layout

\begin_layout Itemize
EXPECTED RESULT: If any expected result was specified for a function this
 field will show what was the expected result.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expected-results"

\end_inset

 shows how to specify an expected result.
\end_layout

\begin_layout Standard
At the very end you will see a small summary on the number of tests ran,
 passed and failed.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
The tutorial
\end_layout

\begin_layout Standard
In this tutorial we will walk you through the usage of 
\emph on
jit-testing
\emph default
 to test some C code.
 We will start by writing some basic and simple C functions, and then some
 tests for it.
\end_layout

\begin_layout Standard
For the sake of simplicity all the C code we write will be located in a
 source file named 
\emph on
cfile.c
\emph default
and our test file will be named 
\emph on
test.jtl
\emph default
.
 
\end_layout

\begin_layout Standard
NOTE: For the examples in which we make use of the C standard library (stdio.h,
 stdlib.h, etc.) you will need to have properly installed such libraries and
 tell 
\emph on
jit-testing
\emph default
 where they live.
 For windows users a small folder with the standard C standard library will
 be provided and you can run the tool on that same folder.
\end_layout

\begin_layout Standard
Since 
\emph on
jit-testing
\emph default
 is a command line tool for this tutorial you will need two things open
 at all times:
\end_layout

\begin_layout Itemize
Command line window (also known as shell or terminal in the linux world).
\end_layout

\begin_deeper
\begin_layout Itemize
Make sure you change to the directory where you placed the folder 
\emph on
jit-testing-tutorial.
\end_layout

\end_deeper
\begin_layout Itemize
Text editor (emacs, vi, notepad++, etc.)
\end_layout

\begin_layout Subsection
The basics
\end_layout

\begin_layout Subsubsection
The simplest test
\end_layout

\begin_layout Standard
In your text editor create a file named 
\emph on
cfile.c
\emph default
 then write the following function in it.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		// cfile.c
\end_layout

\begin_layout Plain Layout

		void my_function() { 
\end_layout

\begin_layout Plain Layout

			return; 
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then create the test file 
\emph on
test_file.jtl
\emph default
 and type the function we want to call.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		# test.jtl		
\end_layout

\begin_layout Plain Layout

		my_function(); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the semi-colon at the end of the function, follows the same syntax
 as C for calling a function.
 Also note that you can place comments in your test file starting with the
 character 
\emph on
#
\emph default
.
 
\end_layout

\begin_layout Standard
Open a command line, shell or terminal in your operating system and then
 to run the above test on the function we just wrote type the following
 command line: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		jit-testing cfile.c -t test.jtl 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first argument 
\emph on
jit-testing
\emph default
 receives is your C source code, then the command line flag 
\emph on
-t filename 
\emph default
indicates what is the test file.
 You
\emph on
 
\emph default
will see some output reporting the results of executing the function defined
 in the test file.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:jit-testing-output"

\end_inset

 describes what the output means.
\end_layout

\begin_layout Standard
Running a test with 
\emph on
jit-testing
\emph default
 is as simple as typing the function in the test file as if you were calling
 a function in C code.
 What the tool will do is taking the given test function 
\emph on
my_function()
\emph default
, it will search for its definition in the input C files, it will compile
 and execute it using LLVM JIT Execution engine.
 Since this is a void function the tool assumes the test has passed if it
 completed its execution without interruption.
\end_layout

\begin_layout Subsubsection
Passing arguments to a functions 
\end_layout

\begin_layout Standard
Now we will see how to call a function takes some parameters and returns
 a value.
 Type the following function in your file 
\emph on
some_file.c
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		int sum(int a, int b) {
\end_layout

\begin_layout Plain Layout

			return a+b;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then write down a test for it which simply calls it with any parameter you
 want in 
\emph on
test_file.jtl.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

		sum(2,2);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Execute the tests with the command
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		jit-testing cfile.c -t test.jtl 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the function has no syntax errors 
\emph on
jit-testing
\emph default
 will run it and report the status of it as passed.
\end_layout

\begin_layout Subsubsection
Expected results
\begin_inset CommandInset label
LatexCommand label
name "sub:Expected-results"

\end_inset

 
\end_layout

\begin_layout Standard
A function is one of the most important elements in which a program is distribut
ed and the execution of any program depends on the return values of such
 functions.
\end_layout

\begin_layout Standard
You can compare the actual result of a given function with an expected result
 with the following syntax in your 
\emph on
test file
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		sum(2,2) == 4;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This syntax may feel awkward for a C programmer, however it tells the tool
 that the return value from calling the function 
\emph on
sum()
\emph default
 should be compared with the value 4
\emph on
.
 
\end_layout

\begin_layout Standard
Execute the test and see what reports tells.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		jit-testing cfile.c -t test.jtl 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 supports the following operators for comparing the return value of a function
 with any value you give it.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		sum(2,2) != 4;
\end_layout

\begin_layout Plain Layout

		sum(2,2) == 4;
\end_layout

\begin_layout Plain Layout

		sum(2,2) >= 4;
\end_layout

\begin_layout Plain Layout

		sum(2,2) <= 4;
\end_layout

\begin_layout Plain Layout

		sum(2,2) > 4;
\end_layout

\begin_layout Plain Layout

		sum(2,2) < 4;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The comparison operators behave and follow the same rules from a C program.
 Try writing some tests that make use of these operators.
\end_layout

\begin_layout Subsection*
What values can I use as expected result?
\end_layout

\begin_layout Standard
As of now the values you may use as expected result are
\emph on
:
\end_layout

\begin_layout Itemize
Constant integers
\emph on
 
\emph default
(only decimal notation is supported, hexadecimal and octal is in the 
\begin_inset Quotes eld
\end_inset

to do
\begin_inset Quotes erd
\end_inset

 list).
\end_layout

\begin_layout Itemize
Floating point constants.
\end_layout

\begin_layout Itemize
Characters denoted with the syntax 'X' where X is any valid ASCII character.
\end_layout

\begin_layout Itemize
C-like strings: 
\begin_inset Quotes eld
\end_inset

this is a string
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
How 
\emph on
jit-testing
\emph default
 will treat each value is shown the following code snippets in comments.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		# It will take the ASCII value of 'a' (49)
\end_layout

\begin_layout Plain Layout

		sum(2,2) == 'a';
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# If sum returns an unsigned value,
\end_layout

\begin_layout Plain Layout

		# -47 will be treated as unsigned value
\end_layout

\begin_layout Plain Layout

		sum(2,2) == -47;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# It will take the memory address of the
\end_layout

\begin_layout Plain Layout

		# string and casting it to whatever data
\end_layout

\begin_layout Plain Layout

		# type the function returns
\end_layout

\begin_layout Plain Layout

		sum(2,2) == "this is a string";		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In all cases the tool will cast the expected value to whatever data type
 the function under test returns and then perform the comparison.
 The expected value is ignored for functions that return 'void'.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
To wrap up and use all you have learned in this section try writing a function
 that calculates the factorial of a number using both a recursive and iterative
 solution.
 
\end_layout

\begin_layout Standard
Today is your lucky as I will provide those functions for you :)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		int fact_1(int a) {   
\end_layout

\begin_layout Plain Layout

			if(1 == a) return a;   
\end_layout

\begin_layout Plain Layout

			return a * factorial(a-1); 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		int fact_2(int a) {   
\end_layout

\begin_layout Plain Layout

			int i = 1;   
\end_layout

\begin_layout Plain Layout

			while(a) i *= a--;   
\end_layout

\begin_layout Plain Layout

			return i; 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "example-factor"

\end_inset


\end_layout

\begin_layout Standard
Try writing some tests for these two functions in the test file.
 Also try writing your own versions of these two functions and test them
 all using 
\emph on
jit-testing
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Managing program state
\begin_inset CommandInset label
LatexCommand label
name "sub:Managing-program-state"

\end_inset


\end_layout

\begin_layout Standard
Any non-trivial program will contain its own state represented as a set
 of data structures which are modified by a series of function calls.
 Sometimes a given function behavior depends not only on the parameter values
 it receives but also on the current value of one or several global variables
 or structures, or even calling other functions before in a specific order.
\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 lets you define the state of your program by using 2 keywords from the
 
\emph on
jit-testing language: 
\family typewriter
\emph default
before
\family default
\emph on
 
\emph default
and
\emph on
 
\family typewriter
\emph default
after.
\end_layout

\begin_layout Standard
The syntax for these two keywords is as follow:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		[before { ...
 }]
\end_layout

\begin_layout Plain Layout

		function_under_test();
\end_layout

\begin_layout Plain Layout

		[after { ...
 }]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You have to write the 
\family typewriter
before
\family default
\emph on
 
\emph default
keyword before the function you want to test and type the 
\family typewriter
after
\family default
 keyword after the function you want to test.
 The curly braces are mandatory for both the 
\family typewriter
before
\family default
 and 
\family typewriter
after
\family default
 keywords.
 The squared brackets indicate that either statement are optional for your
 test.
\end_layout

\begin_layout Standard
The important thing to note here is that you can specify 3 types of statements
 inside the curly braces that 
\series bold
will be executed 
\emph on
before
\emph default
 and 
\emph on
after
\series default
 
\emph default
the function under test respectively in the order they appear.
 You can have 3 different of statements inside the curly braces and they
 are described with the following examples.
\end_layout

\begin_layout Subsubsection
Modifying global variables
\end_layout

\begin_layout Standard
Write the following code in your source file.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		int state; /* Global variable */
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		int get_state() {   
\end_layout

\begin_layout Plain Layout

			return state; 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Write the following test in your test file.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		get_state() == 0;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Run this test through the command line.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		jit-testing cfile.c -t test.jtl 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Remember that the C standard specificies that global variables will be initializ
ed to 0, thus our test succeeds and 
\emph on
jit-testing
\emph default
 will report the actual result.
\end_layout

\begin_layout Standard
Now try writing the following test:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		before { state = 10; } # Assignment operator =
\end_layout

\begin_layout Plain Layout

		get_state() == 0; 	 # Comparison operator ==
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Try running this test and you will see that it fails.
 The reason why it fails is because 
\emph on
jit-testing
\emph default
 modified the variable 
\emph on
state
\emph default
 and assigned a 
\emph on
10
\emph default
 to it right before executing the function 
\emph on
get_state()
\emph default
.
 Thus the actual result from calling 
\emph on
get_state()
\emph default
 is 10.
\end_layout

\begin_layout Subsubsection
Checking global variables values
\end_layout

\begin_layout Standard
Imagine the 
\emph on
get_state()
\emph default
 function has a return type of 
\emph on
void
\emph default
 and there was no way for us to check which value the variable 
\emph on
state
\emph default
 has after calling the function under test.
 This problem can be solved by making a comparison using the 
\emph on
after
\emph default
 keyword.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		before { state = 10; } # Assignment operator =
\end_layout

\begin_layout Plain Layout

		get_state(); 	 # Imagine this function returns 'void'
\end_layout

\begin_layout Plain Layout

		after { state == 10; } # Comparison operator ==
\end_layout

\end_inset

This test will succeed as 
\emph on
jit-testing
\emph default
 will check that the variable 
\emph on
state
\emph default
 has a value of 
\emph on
10 after
\emph default
 running the function under test.
 Note that when there is no expected value specified after function under
 test the return value is ignored regardless of its data type.
\end_layout

\begin_layout Subsubsection
Calling functions
\series medium
 
\series default
\emph on
before
\emph default
 and 
\emph on
after
\emph default
 a function under test
\begin_inset CommandInset label
LatexCommand label
name "sub:Calling-functions-before"

\end_inset


\end_layout

\begin_layout Standard
Now add the following function to your C source file 
\emph on
some_file.c
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		void modify_state() {   
\end_layout

\begin_layout Plain Layout

			state += 5; 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we will modify the variable 
\emph on
state
\emph default
 by calling a function rather than doing an assignment.
 Here is the new test:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		before { modify_state(); } # Function call, state == 5
\end_layout

\begin_layout Plain Layout

		get_state() == 5; # Passes
\end_layout

\begin_layout Plain Layout

		after { modify_state(); } # You can call a function call here to, state
 == 10
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This test will succed because the function 
\emph on
modify_state()
\emph default
 is called before the 
\emph on
get_state()
\emph default
 function modifying the global variable.
 In the 
\family typewriter
after
\family default
 statement we also call the function that modifies the global variable.
 Calling this function in the 
\family typewriter
after
\family default
\emph on
 
\emph default
statement
\emph on
 
\emph default
for
\emph on
 
\emph default
this toy example is useless, but you can think of calling a function that
 cleans up all the things done in the 
\family typewriter
before
\family default
 statement or during the function under test.
\end_layout

\begin_layout Standard
NOTE: There is one important thing to note here.
 
\emph on
jit-testing 
\emph default
will backup any global variable you modify in the 
\family typewriter
after
\family default
 or 
\family typewriter
before
\family default
 statements using the assignment operator 
\family typewriter
=
\family default
 and then restore their original value right before starting executing the
 next.
 Thus leaving the program state in its original value before starting execution
 of the current.
 However, 
\emph on
jit-testing
\emph default
 will not detect when a function called in the 
\family typewriter
after
\family default
 or 
\family typewriter
before
\family default
 statements has modified a global variable, thus the modified variables
 will remain with this new value for the next test that is run.
 If you call any 
\emph on
setup
\emph default
 function in the 
\family typewriter
before
\family default
 statement, make sure you call a 
\emph on
cleanup
\emph default
 function in the 
\family typewriter
after
\family default
 statement to leave the program state in an optimal state in which other
 tests can be run.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
In this section we just learned that we can use the 
\family typewriter
before
\family default
 and 
\family typewriter
after
\family default
 keywords to execute three different types of statements:
\end_layout

\begin_layout Enumerate
Variable assignment 
\family typewriter
variable = X
\family default
 where X is any value as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expected-results"

\end_inset

 and 
\family typewriter
variable
\family default
 is a global variable of any type.
 For pointer types see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Automatic-memory-allocation"

\end_inset

.
\end_layout

\begin_layout Enumerate
Function call.
\end_layout

\begin_layout Enumerate
Variable comparison with any value as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expected-results"

\end_inset

.
\end_layout

\begin_layout Standard
The syntax for the before
\emph on
 
\emph default
and
\emph on
 after 
\emph default
keywords is as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		[before {<variable assignment>* | <function call>* | <variable comparison>*}]
\end_layout

\begin_layout Plain Layout

		function_under_test();
\end_layout

\begin_layout Plain Layout

		[after { <variable assignment>* | <function call>* | <variable comparison>*
 }]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the little star to the right of each statement.
 That indicates that you can have as many statements as you want in the
 
\emph on
before
\emph default
 and 
\emph on
after 
\emph default
statements or none of them in any order.
 The squared bracket indicate that both the before and after statements
 are optional for a function under test.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Grouping related tests
\begin_inset CommandInset label
LatexCommand label
name "sub:Grouping-related-tests"

\end_inset


\end_layout

\begin_layout Standard
Any non-trivial program will have its set of tests, and often times the
 amount such tests will be big.
 A common practice to maintain a set of tests in the long term is to group
 the tests into related sets of tests that comply with a certain criteria.
\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 lets you group any amount of tests by using the keyword 
\family typewriter
group
\family default
.
 The syntax is as follow:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		group [Name] {
\end_layout

\begin_layout Plain Layout

			...
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can optionally provide a name for a given group.
\end_layout

\begin_layout Standard
The reason to have groups is mainly to 2 things: 
\end_layout

\begin_layout Enumerate
Provide a program state for a set of tests in order to avoid having redundant
\emph on
 
\family typewriter
\emph default
before
\family default
 and 
\family typewriter
after
\family default
\emph on
 
\emph default
statements for the same set of tests.
\end_layout

\begin_layout Enumerate
Provide a way to filter and customize the reports for each 
\family typewriter
group
\family default
 of tests.
\end_layout

\begin_layout Subsubsection
The default group
\end_layout

\begin_layout Standard
Taking all the examples we've done in the previous section you should have
 a 
\emph on
test.jtl
\emph default
 file that looks somewhat like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		# test_file.jtl
\end_layout

\begin_layout Plain Layout

		my_function(); 
\end_layout

\begin_layout Plain Layout

		sum(2,2);
\end_layout

\begin_layout Plain Layout

		sum(2,2) == 4; 
\end_layout

\begin_layout Plain Layout

		sum(2,2) != 5; 
\end_layout

\begin_layout Plain Layout

		fact_1(3) == 6; # provided in section 2.1 Summary
\end_layout

\begin_layout Plain Layout

		fact_2(3) == 6; # provided in section 2.1 Summary
\end_layout

\begin_layout Plain Layout

		get_state() == 0;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By default 
\emph on
jit-testing
\emph default
 adds all the tests in a test file into a 
\emph on
default
\emph default
 
\emph on
group
\emph default
 which is named 
\emph on
group_0
\emph default
.
 You will see in the test reports a 'group_0' for every test you run.
\end_layout

\begin_layout Subsubsection
Nesting groups
\end_layout

\begin_layout Standard
Let us take some of the tests from the 
\emph on
test_file.jtl
\emph default
 and group them into nested groups.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		# test_file.jtl
\end_layout

\begin_layout Plain Layout

		my_function(); 
\end_layout

\begin_layout Plain Layout

		group A {
\end_layout

\begin_layout Plain Layout

			sum(2,2);
\end_layout

\begin_layout Plain Layout

			group B {
\end_layout

\begin_layout Plain Layout

				sum(2,2) == 4;	 
\end_layout

\begin_layout Plain Layout

				group C {
\end_layout

\begin_layout Plain Layout

					sum(2,2) != 5;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		group D {
\end_layout

\begin_layout Plain Layout

			fact_1(3) == 6;
\end_layout

\begin_layout Plain Layout

			fact_2(3) == 6;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		get_state() == 0;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inside a group you can have any number of tests or even any number of nested
 groups.
 There is no limit in how many groups can be nested.
 The tests and groups found within another group will be executed in the
 same order they appear in your test file.
\end_layout

\begin_layout Subsubsection
Managing program states for a given group
\end_layout

\begin_layout Standard
Recall section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Managing-program-state"

\end_inset

 in which we learned how to modify the program state for a given test with
 the keywords 
\family typewriter
before
\family default
 and 
\family typewriter
after
\family default
.
 We can also modify and check the program state for a 
\emph on
group
\emph default
 of tests using the 
\family typewriter
before_all
\family default
 and 
\family typewriter
after_all
\family default
 keywords.
 This is their syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		group [Name] {
\end_layout

\begin_layout Plain Layout

			[before_all { ...
 }]
\end_layout

\begin_layout Plain Layout

			...
\end_layout

\begin_layout Plain Layout

			[after_all { ...
 }]
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These two keywords will modify the program state for the current group they
 belong to.
 Note that both statements are optional.
 The only restriction if they are used is that the 
\family typewriter
before_all
\family default
 statement has to be defined at the beginning of the group before all the
 tests and the 
\family typewriter
after_all
\family default
 statement has to be defined at the end of the group after all the tests
 in that group.
\end_layout

\begin_layout Standard
For instance the following examples are valid tests.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		group E { 	 	
\end_layout

\begin_layout Plain Layout

			before_all { state = 10; } # Executed before all the tests in this group
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			get_state() == 10; # test 1
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			# jit-testing does not track what's changed inside this function call
\end_layout

\begin_layout Plain Layout

			before { modify_state(); }
\end_layout

\begin_layout Plain Layout

			get_state() == 15; #test 2
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

			modify_state(); # test 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			after_all  { state == 20; } # Executed after all the tests in this group
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		 
\end_layout

\begin_layout Plain Layout

		group F {
\end_layout

\begin_layout Plain Layout

			before_all { state = 5; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			get_state() == 5; 
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			before { modify_state(); } 	
\end_layout

\begin_layout Plain Layout

			get_state() == 10; 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		group G { 	
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			get_state() == 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			after_all { modify_state(); }
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All these are valid tests and they all pass.
 Try running writing these tests in your 
\emph on
test.jtl 
\emph default
file
\emph on
.
 
\emph default
If you have any doubt regarding the results of these tests and when the
 global variables are modified please refer to the note at the end of section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Calling-functions-before"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
In this section we learned how to group tests by using the keyword 
\family typewriter
group
\family default
.
 We also learned how to modify the program state for a specific group by
 using the keywords 
\family typewriter
before_all
\family default
 and 
\family typewriter
after_all
\family default
.
 The final syntax for the 
\family typewriter
group
\family default
 keyword is as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

group [Name] {
\end_layout

\begin_layout Plain Layout

	[before_all { <variable assignment>* | <function call>* | <variable comparison>
* }]
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	[after_all  { <variable assignment>* | <function call>* | <variable comparison>
* }]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Both the 
\family typewriter
before_all
\family default
 and 
\family typewriter
after_all
\family default
 statements are optional for a given group, and they can contain any number
 of variable assignments, function calls or variable comparisons with an
 expected value.
 Note the order in which you can define the 
\family typewriter
before_all
\family default
 and 
\family typewriter
after_all
\family default
 statements, they need to be defined at the beginning and end of the group
 respectively.
 A group can also have an optional name.
 If you omit this name the tool will assign this group an automatically
 generated group name.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Structures as global variables
\end_layout

\begin_layout Standard
If you are using a structure as a global variable to keep track of your
 program state you can assign any value to it just like any other global
 variable.
 The only difference is that you have to use C89 struct initialization list
 syntax to initialize the values of your struct.
 Here is an example of such syntax.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		/* Example C code */
\end_layout

\begin_layout Plain Layout

		struct Pair {
\end_layout

\begin_layout Plain Layout

			int a;
\end_layout

\begin_layout Plain Layout

			int b;
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

		struct Pair my_pair = { 10, 20 }; // a==10, b==20
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The important thing here is that you have to provide a valid initialization
 value for the variable types in the same order as they declared.
 If you omit an initialization value it has to be for the variables declared
 at the end of the struct.
 Any variable which is not given an initiazilation value using this syntax
 will be initialized to 0.
 For instance:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		struct Pair my_pair = {10}; // a==10, b==0
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Struct initialization list
\begin_inset CommandInset label
LatexCommand label
name "sub:Struct-initialization-list"

\end_inset


\end_layout

\begin_layout Standard
Let us write a function that prints the contents of a global struct.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Testing-code-which"

\end_inset

 on how to use the C standard library.
 Open your 
\emph on
cfile.c
\emph default
 and type the following.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		/** some_file.c **/
\end_layout

\begin_layout Plain Layout

		#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		struct Pair { 	
\end_layout

\begin_layout Plain Layout

			int a; 	
\end_layout

\begin_layout Plain Layout

			int b; 
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		struct NestedPair { 	
\end_layout

\begin_layout Plain Layout

			int a; 	
\end_layout

\begin_layout Plain Layout

			int b; 	
\end_layout

\begin_layout Plain Layout

			struct Pair nested; 
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		struct NestedPair global_pair;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		void print_global_pair(){
\end_layout

\begin_layout Plain Layout

			printf("global_pair.a = %d
\backslash
n", global_pair.a); 	
\end_layout

\begin_layout Plain Layout

			printf("global_pair.b = %d
\backslash
n", global_pair.b); 	
\end_layout

\begin_layout Plain Layout

			printf("global_pair.subpair.a = %d
\backslash
n", global_pair.nested.a);
\end_layout

\begin_layout Plain Layout

			printf("global_pair.subpair.b = %d
\backslash
n", global_pair.nested.b); 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now write the following tests in your 
\emph on
test_file.jtl
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		# test 1 
\end_layout

\begin_layout Plain Layout

		print_global_pair();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# test 2 
\end_layout

\begin_layout Plain Layout

		before {global_pair = {1}; } 
\end_layout

\begin_layout Plain Layout

		print_global_pair();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# test 3 
\end_layout

\begin_layout Plain Layout

		before {global_pair = {1,2}; } 
\end_layout

\begin_layout Plain Layout

		print_global_pair();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# test 4 
\end_layout

\begin_layout Plain Layout

		before {global_pair = {1,2, {5} }; } 
\end_layout

\begin_layout Plain Layout

		print_global_pair();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# test 5 
\end_layout

\begin_layout Plain Layout

		before {global_pair = {1,2, {5,6} }; } 
\end_layout

\begin_layout Plain Layout

		print_global_pair();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These 5 tests show the basics of C struct initialization list syntax in
 
\emph on
jit-testing
\emph default
.
 The first test will print the contents of the global struct 
\family typewriter
global_pair
\family default
.
 On the following tests we just modify the contents of the struct 
\family typewriter
global_pair
\family default
 one element at a time to appreciate how the struct initialization works,
 even for nested structs.
 Note that you cannot assign values starting from the last element in the
 struct, it hast to start from the first element.
\end_layout

\begin_layout Subsubsection
Pointers to structs
\end_layout

\begin_layout Standard
The initialization of structs through a pointer is pretty much the same
 as we just saw with a little difference.
 However we need to explain how 
\emph on
jit-testing
\emph default
 works with pointers.
 We will explain that and also initializing structs with poitners in the
 next section.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
In this section we learned how can initialize struct wiht the struct initializat
ion list syntax.
 We have to initialize the struct fields in the same order they were declared.
 If we omit a struct field has to be one that was las declared in the struct.
 We can also initialize structs that contain more structs.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pointers
\end_layout

\begin_layout Standard
As C programmer you already know the importance of pointers and how many
 times the design of functions revolves around the usage of pointers.
 Many functions that take a pointer to any data type assume that the memory
 for that data type was already allocated somwhere else in the code.
 This poses a problem for testing functions that make use of pointers.
 
\emph on
jit-testing 
\emph default
solves this problem by providing a simple syntax to allocate memory for
 a given function.
\end_layout

\begin_layout Subsubsection
Automatic memory allocation
\begin_inset CommandInset label
LatexCommand label
name "sub:Automatic-memory-allocation"

\end_inset


\end_layout

\begin_layout Standard
Whenever you have a function that takes a pointer or a global variable of
 any pointer type, you can tell 
\emph on
jit-testing
\emph default
 to allocate memory for it by using the following syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		[n]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using the squared brackets and putting inside a non-negative integer value
 will make 
\emph on
jit-testing 
\emph default
to allocate the necessary bytes for the data type the pointer points to.
 That is it allocates 
\family typewriter
n*sizeof(<data type>
\family default
) bytes.
 Let us write an example.
 Write the following C code in your file 
\emph on
some_file.c
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		int * g_ptr = NULL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		void print_g_ptr(){
\end_layout

\begin_layout Plain Layout

			if(g_ptr) 		
\end_layout

\begin_layout Plain Layout

				printf("address: %p, contents: %d
\backslash
n",g_ptr,*g_ptr); 	
\end_layout

\begin_layout Plain Layout

			else 		
\end_layout

\begin_layout Plain Layout

				printf("ERROR g_ptr is NULL pointer!
\backslash
n");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then write a simple test in your test file 
\emph on
test_file.jtl.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			print_g_ptr();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After running this test you should see that your test printed the error
 stating 
\emph on
g_ptr
\emph default
 is a null pointer.
 In order to have a working test we can tell 
\emph on
jit-testing 
\emph default
to allocate memory for the data type pointed to by the pointer.
 Let's do it by writting a new test:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			# allocates enough memory for 1 data type g_ptr points to.
\end_layout

\begin_layout Plain Layout

			before { g_ptr = [1]; }
\end_layout

\begin_layout Plain Layout

			print_g_ptr();
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
jit-testing 
\emph default
will allocate enough memory for 
\emph on
1 integer
\emph default
 because the data type g_ptr points to is an integer.
 If the pointer was a pointer to a char, short integer, or even a struct
 type, 
\emph on
jit-testing
\emph default
 will allocate enough memory for that data type.
 
\end_layout

\begin_layout Standard
This means that you could allocate enough memory for an array of integers
 by writing the following test.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			# allocates enough memory for 1024 data type g_ptr points to.
\end_layout

\begin_layout Plain Layout

			before { g_ptr = [1024]; } 
\end_layout

\begin_layout Plain Layout

			print_g_ptr();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course the function print_g_ptr() only accesses the first element in
 the array, but still 
\emph on
jit-testing
\emph default
 allocates enough memory to fit 1024 integers.
\end_layout

\begin_layout Standard
You don't have to worry about 
\emph on
free
\emph default
ing the memory allocated, 
\emph on
jit-testing 
\emph default
will do that for you automatically after running this test.
 If you want the memory allocated to last for the execution of several tests
 you may want put the expression 
\family typewriter
g_ptr = [n]
\family default
 in a 
\family typewriter
before_all
\family default
 statement.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Grouping-related-tests"

\end_inset

 for more information on 
\family typewriter
group
\family default
s.
\end_layout

\begin_layout Subsubsection
Memory initialization
\begin_inset CommandInset label
LatexCommand label
name "sub:Memory-initialization"

\end_inset


\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 provides an easy way to initialize all the memory allocated for a pointer
 by using the following syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			[n:x]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We just add a colon and then we pass an non-negative integer value 
\family typewriter
x
\family default
 to indicate an initialization value to be stored in every 
\series bold
byte
\series default
 of memory allocated for the given pointer.
 Rewrite the test from previous exercise to initialize the memory:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			# allocates enough memory for 1 data type g_ptr points to.
\end_layout

\begin_layout Plain Layout

			before { g_ptr = [1:5]; } 
\end_layout

\begin_layout Plain Layout

			print_g_ptr();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After running the test you will see that the contents of the memory allocated
 is actually a 
\emph on
5
\emph default
.
\end_layout

\begin_layout Standard
To wrap up this exercise write down the following C function in your file
 
\emph on
cfile.c:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		// Print the contents of the array pointed to by buf
\end_layout

\begin_layout Plain Layout

		void print_buffer(unsigned char *buf, unsigned size) { 	
\end_layout

\begin_layout Plain Layout

			short step = 1; 	
\end_layout

\begin_layout Plain Layout

			unsigned char *i = buf; 	
\end_layout

\begin_layout Plain Layout

			unsigned char *end = buf + size;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			while(i < end) { 		
\end_layout

\begin_layout Plain Layout

				printf("%x ", *i); 		
\end_layout

\begin_layout Plain Layout

				if(step%10 == 0) 			
\end_layout

\begin_layout Plain Layout

				printf("
\backslash
n"); 		
\end_layout

\begin_layout Plain Layout

				++step; 		
\end_layout

\begin_layout Plain Layout

				++i; 	
\end_layout

\begin_layout Plain Layout

			} 	
\end_layout

\begin_layout Plain Layout

			printf("
\backslash
n"); 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And write the following test in your file 
\emph on
test_file.jtl 
\emph default
and then run it
\emph on
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		print_buffer([20:6], 20);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
print_buffer
\family default
 will print 
\family typewriter
size
\family default
 bytes of the array pointed to by 
\family typewriter
buf
\family default
.
 We just tested this function with 
\emph on
jit-testing
\emph default
 by allocating 20 elements of type 
\family typewriter
unsigned char
\family default
 and passing that pointer to the function.
 Then we passed the size of the array which is of 20 
\family typewriter
unsigned char
\family default
s (rememeber the size of an unsigned char is 1 byte).
 After running that function you will see printed on screen the contents
 of the array which is 6.
\end_layout

\begin_layout Standard
If this function received a pointer to an integer 
\family typewriter
int *
\family default
 
\emph on
jit-testing 
\emph default
would have allocated memory for 20 integers, that is 80 bytes.
\end_layout

\begin_layout Subsubsection
Pointers to structures
\end_layout

\begin_layout Standard
If you had a global variable which is a pointer to a struct or a function
 that receives a pointer to a struct and you want to initialize that pointer
 the section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Automatic-memory-allocation"

\end_inset

 and section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Memory-initialization"

\end_inset

 applies the same to pointer to structs.
 If you'd like to initialize each field of the struct just as described
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Struct-initialization-list"

\end_inset

 the only thing you need to change is the initialization value to a struct
 initialization list.
 The following example demonstrates this.
 Write this function in your file 
\emph on
cfile.c
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		// some_file.c
\end_layout

\begin_layout Plain Layout

		void print_ptr_pair(struct NestedPair* ptr) { 	
\end_layout

\begin_layout Plain Layout

			if(ptr) { 		
\end_layout

\begin_layout Plain Layout

				printf("ptr.a = %d
\backslash
n", ptr->a); 		
\end_layout

\begin_layout Plain Layout

				printf("ptr.b = %d
\backslash
n", ptr->b); 		
\end_layout

\begin_layout Plain Layout

				printf("ptr.subpair.a = %d
\backslash
n", ptr->nested.a); 		
\end_layout

\begin_layout Plain Layout

				printf("ptr.subpair.b = %d
\backslash
n", ptr->nested.b); 	
\end_layout

\begin_layout Plain Layout

			} else 		
\end_layout

\begin_layout Plain Layout

				printf("ERROR ptr is NULL pointer!
\backslash
n"); 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Write the following test:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		print_ptr_pair([1:{1,2,{3,4}}]);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can see that instead of providing an integer value to initialize the
 memory allocated, we provide a struct initializer as described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Struct-initialization-list"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
In this section we learned that we can tell 
\emph on
jit-testing 
\emph default
to allocate enough memory for any pointer with the syntax [n:x] which makes
 it allocate 
\family typewriter
n*sizeof(<data type>)
\family default
 bytes and initialize each byte of that allocated memory with the value
 
\family typewriter
x
\family default
.
 If the pointer points to a struct we can allocate memory and initialize
 the values of the struct with the syntax 
\family typewriter
[n:{...}].
\end_layout

\begin_layout Subsection
End of tutorial
\end_layout

\begin_layout Standard
This concludes all the features available in 
\emph on
jit-testing
\emph default
.
 We hope you have found our tool interesting and useful, feel free to keep
 using it or even try to break it.
 If you find any error or bug please send both C source file and test file
 to the authors email 
\family typewriter
elfus0.1@gmail.com.
\end_layout

\begin_layout Standard
Please fill up the survey you have received along with the tutorial.
 Thank you!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
Advanced topics
\end_layout

\begin_layout Subsection
Complex expressions in 
\emph on
jit-testing language
\end_layout

\begin_layout Standard

\emph on
jit-testing 
\emph default
does not support complex expressions like the C programming language does.
 For instance the following expression is not supported:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		int var = 0;
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

		var = fact(1) + fact(3);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reason to not support complex expressions is that the author didn't
 want the 
\emph on
jit-testing language
\emph default
 to become another programming language on its own.
 The objectives behind the design of this language has always been to keep
 it small and simple, therefore a small portion of some statements syntax
 was borrowed from the C language in adition to the keywords 
\family typewriter
group
\family default
, 
\family typewriter
before
\family default
, 
\family typewriter
after
\family default
, 
\family typewriter
before_all
\family default
, and 
\family typewriter
after_al
\family default
l that reflect some common concepts, i.e.

\series bold
 test fixtures
\series default
, from the 
\emph on
Test Driven Development
\emph default
 methodology.
\end_layout

\begin_layout Standard
The whole 
\emph on
jit-testing language 
\emph default
syntax can be summarized like this (this is not a BNF notation):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		[before {
\end_layout

\begin_layout Plain Layout

			<variable assignment>*
\end_layout

\begin_layout Plain Layout

			| <function call>*
\end_layout

\begin_layout Plain Layout

			| <variable comparison>*
\end_layout

\begin_layout Plain Layout

		}]
\end_layout

\begin_layout Plain Layout

		<test function>
\end_layout

\begin_layout Plain Layout

		[after {
\end_layout

\begin_layout Plain Layout

			<variable assignment>*
\end_layout

\begin_layout Plain Layout

			| <function call>*
\end_layout

\begin_layout Plain Layout

			| <variable comparison>*
\end_layout

\begin_layout Plain Layout

		}]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		group [NAME] {
\end_layout

\begin_layout Plain Layout

			[before_all {
\end_layout

\begin_layout Plain Layout

				<variable assignment>*
\end_layout

\begin_layout Plain Layout

				| <function call>*
\end_layout

\begin_layout Plain Layout

				| <variable comparison>*
\end_layout

\begin_layout Plain Layout

			}]
\end_layout

\begin_layout Plain Layout

			...
\end_layout

\begin_layout Plain Layout

			[after_all {
\end_layout

\begin_layout Plain Layout

				<variable assignment>*
\end_layout

\begin_layout Plain Layout

				| <function call>*
\end_layout

\begin_layout Plain Layout

				| <variable comparison>*
\end_layout

\begin_layout Plain Layout

			}]
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The square brackets indicate optional statements.
 The start next to some statements indicate they are optional.
 Groups are optional and they can contain nested groups or just tests.
\end_layout

\begin_layout Subsection
Testing code which uses the C standard library
\begin_inset CommandInset label
LatexCommand label
name "sub:Testing-code-which"

\end_inset


\end_layout

\begin_layout Standard
While writting tests you will find code that uses the C standard library
 stdio.h, stdlib.h, etc.
 and 
\emph on
jit-testing
\emph default
 may complain about not finding the header files for the libraries.
 All you need to do is to provide the command line flag 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			-I path/to/include/files
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For linux users this won't be much of a problem because 
\emph on
jit-testing
\emph default
 will probably find the correct path to the standard library if it was properly
 installed using the proper package manager or installer.
\end_layout

\begin_layout Standard
For Windows users two small folders will be provided with the 
\emph on
jit-testing 
\emph default
binary include and lib.
 Assuming the binary is on the same folder level as the include and lib
 folder you can execute the tool with the following command:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			jit-testing -I include some_file.c --test-file test_file.jtl
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
3rd party libraries
\begin_inset CommandInset label
LatexCommand label
name "sub:3rd-party-libraries."

\end_inset


\end_layout

\begin_layout Standard
In case the C code you are testing makes use of a 3rd party library you
 will need to tell 
\emph on
jit-testing 
\emph default
where their header and source files are located by using the command lines
 as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Testing-code-which"

\end_inset


\end_layout

\begin_layout Section
Current Limitations
\begin_inset CommandInset label
LatexCommand label
name "sec:Limitations"

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
jit-testing
\emph default
 tool has the following limitations:
\end_layout

\begin_layout Itemize
It can process only 1 C source file at a time, but this will change in the
 short time.
\end_layout

\begin_deeper
\begin_layout Itemize
This restricts testing of code spread into several C source files.
\end_layout

\end_deeper
\begin_layout Itemize
Output customization.
\end_layout

\begin_deeper
\begin_layout Itemize
The end user can't customize the info and format of what is printed on screen
\end_layout

\end_deeper
\begin_layout Itemize
Decimal notation only for integers in the test file.
\end_layout

\begin_layout Section
Under development
\begin_inset CommandInset label
LatexCommand label
name "sec:Under-development"

\end_inset


\end_layout

\begin_layout Standard
The author is actively working to support the following features:
\end_layout

\begin_layout Itemize
Quick function mockup generation.
\end_layout

\begin_deeper
\begin_layout Itemize
The tool generates a default function definition and uses it to replace
 whatever function the user desires for a specific test.
 This feature works with function declarations and function definitions.
\end_layout

\end_deeper
\begin_layout Itemize
Process several C source files in one command line.
\end_layout

\begin_deeper
\begin_layout Itemize
The user will be able to test code spread across several files.
\end_layout

\end_deeper
\begin_layout Itemize
Output customization.
\end_layout

\begin_deeper
\begin_layout Itemize
The user will be able to customize the tool output with command line arguments
 or a file that describes how the output should be.
\end_layout

\end_deeper
\begin_layout Itemize
Support for hexadecimal and octal notation for integer values.
\end_layout

\end_body
\end_document
