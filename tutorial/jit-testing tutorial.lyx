#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily \small},columns=fullflexible"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
JIT-TESTING Tutorial
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection*
What is it? 
\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 is a simple command line tool to perform 
\emph on
unit testing in C code
\emph default
 using the LLVM Just In Time (JIT) engine and some of the Clang APIs.
\end_layout

\begin_layout Subsection*
Objectives 
\end_layout

\begin_layout Standard
The main objectives behind the design and implementation of this tool are:
 
\end_layout

\begin_layout Itemize
Minimize the amount of test code you need to write for your software written
 in C.
 
\end_layout

\begin_layout Itemize
Simplify the test code you write.
 
\end_layout

\begin_deeper
\begin_layout Itemize
We believe that writing a test for a function should be as simple as if
 you were calling that function with its parameters somewhere else in your
 program.
\end_layout

\end_deeper
\begin_layout Itemize
Minimize the compile times for your tests and in turn for your program.
 
\end_layout

\begin_deeper
\begin_layout Itemize
The jit-testing tool will actually compile only the functions you are testing,
 leaving the rest untouched.
 
\end_layout

\end_deeper
\begin_layout Itemize
Encourage Test Driven Development (TDD) and unit testing among C programmers.
\end_layout

\begin_layout Standard
While the main focus of our tool has always been oriented to unit testing
 and TDD we have found during the early stages of development and testing
 that this tool might be a good resource for educational purposes for C
 novice programmers and universities.
\end_layout

\begin_layout Subsubsection*
How does it work? 
\end_layout

\begin_layout Standard

\emph on
jit-testing 
\emph default
takes as input 2 important things: your C source code and a test file.
\end_layout

\begin_layout Itemize

\emph on
C source code
\emph default
: jit-testing makes use of the Clang APIs to analyze and process the source
 code, hence it will behave pretty much like a compiler.
 This means that you will need to tell it where are all your header files
 and libraries live.
 If you're familiar with GCC or Clang you will figure out you can do this
 by using the usual compiler flags for finding header files and linking
 source code in several files and libraries, i.e.
 -I or -L.
 
\end_layout

\begin_layout Itemize

\emph on
Test file
\emph default
: This is a text file with the extension 
\emph on
jtl
\emph default
.
 In order for this tool to understand what you want to test and expecting
 from a test you need to use the 
\emph on
Jit-Testing Language
\emph default
 (
\emph on
jtl
\emph default
).
 Don't worry about learning a new language, you will see in the rest of
 this tutorial that this language is really small, simple and based on a
 small subset of the C syntax.
 If you are comfortable with C's syntax then you're pretty much done learning
 this new language.
\end_layout

\begin_layout Standard
Upon receiving these 2 inputs the tool will analyze the C code using Clang
 APIs and will generate code for only those functions described in the test
 file and then run them using the LLVM JIT Execution Engine.
 Then a small report will be provided by the tool about the tests ran.
\end_layout

\begin_layout Standard
From a high level perspective the following diagram describes how JIT-TESTING
 works.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename jit-testing high level.jpg
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
High level view of how jit-testing works
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
The tutorial
\end_layout

\begin_layout Standard
In this tutorial we will walk you through the usage of 
\emph on
jit-testing
\emph default
 to test some C code.
 We will start by writing some basic and simple C functions, and then some
 tests for it.
\end_layout

\begin_layout Standard
For the sake of simplicity all the C code we write will be located in a
 source file named 
\emph on
some_file.c
\emph default
and our test file will be named 
\emph on
test_file.jtl
\emph default
.
 In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Testing-code-spread"

\end_inset

 we will explain how to test C code across multiple files.
\end_layout

\begin_layout Standard
NOTE: For the examples in which we make use of the C standard library (stdio.h,
 stdlib.h, etc.) you will need to have properly installed such libraries and
 tell 
\emph on
jit-testing
\emph default
 where they live.
 For windows users a small folder with the standard C standard library will
 be provided.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Testing-code-which"

\end_inset

 for more information on running the tool from the command line.
\end_layout

\begin_layout Subsection
The basics
\end_layout

\begin_layout Subsubsection
The simplest test
\end_layout

\begin_layout Standard
Open your favorite text editor and create a file named 
\emph on
some_file.c
\emph default
 then write the following function in it.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		// some_file.c
\end_layout

\begin_layout Plain Layout

		void my_function() { 
\end_layout

\begin_layout Plain Layout

			return; 
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then create the test file 
\emph on
test_file.jtl
\emph default
 and type the function we want to call.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		# test_file.jtl		
\end_layout

\begin_layout Plain Layout

		my_function(); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the semi-colon at the end of the function, follows the same syntax
 as C for calling a function.
 Also note that you can place comments in your test file starting with the
 character 
\emph on
#
\emph default
.
 
\end_layout

\begin_layout Standard
Open a command line, shell or terminal in your operating system and then
 to run the above test on the function we just wrote can be done with the
 following command line: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		jit-testing some_file.c --test-file test_file.jtl 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You will see some output reporting the results of executing the function
 defined in the test file.
\end_layout

\begin_layout Standard
Running a test with 
\emph on
jit-testing
\emph default
 is as simple as typing the function in the test file as if you were calling
 a function in C code.
 What the tool will do is to take the given test function 
\emph on
my_function()
\emph default
, it will search for its definition in the input C files, it will compile
 and execute it using LLVM JIT Execution engine.
 Since this is a void function the tool assumes the test has passed if it
 completed its execution without interruption.
\end_layout

\begin_layout Subsubsection
Passing arguments to a functions 
\end_layout

\begin_layout Standard
Now we will see how to call a function takes some parameters and returns
 a value.
 Type the following function in your file 
\emph on
some_file.c
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		int sum(int a, int b) {
\end_layout

\begin_layout Plain Layout

			return a+b;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then write down a test for it which simply calls it with any parameter you
 want in 
\emph on
test_file.jtl.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

		sum(2,2);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Execute the tests with the command
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

		jit-testing some_file.c --test-file test_file.jtl 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the function has no syntax errors 
\emph on
jit-testing
\emph default
 will run it and report the status of it as passed.
\end_layout

\begin_layout Subsubsection
Expected results
\begin_inset CommandInset label
LatexCommand label
name "sub:Expected-results"

\end_inset

 
\end_layout

\begin_layout Standard
A function is one of the most important elements in which a program is distribut
ed and the execution of any program depends on the return values of such
 functions.
\end_layout

\begin_layout Standard
You can compare the actual result of a given function with an expected result
 with the following syntax in your test file.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		sum(2,2) == 4;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This syntax may feel awkward for a C programmer, however it tells the tool
 that the return value from calling the function 
\emph on
sum()
\emph default
 should be compared with the value 4
\emph on
.
 
\end_layout

\begin_layout Standard
Execute the test and see what reports tells.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		jit-testing some_file.c --test-file test_file.jtl 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 supports the following operators for comparing the return value of a function
 with any value you give it.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		sum(2,2) != 4;
\end_layout

\begin_layout Plain Layout

		sum(2,2) == 4;
\end_layout

\begin_layout Plain Layout

		sum(2,2) >= 4;
\end_layout

\begin_layout Plain Layout

		sum(2,2) <= 4;
\end_layout

\begin_layout Plain Layout

		sum(2,2) > 4;
\end_layout

\begin_layout Plain Layout

		sum(2,2) < 4;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The comparison operators behave and follow the same rules from a C program.
 Try writing some tests that make use of these operators.
\end_layout

\begin_layout Subsection*
What values can I use as expected result?
\end_layout

\begin_layout Standard
As of now the values you may use as expected result are
\emph on
:
\end_layout

\begin_layout Itemize
Constant integers
\emph on
 
\emph default
(only decimal notation is supported, hexadecimal and octal is in the 
\begin_inset Quotes eld
\end_inset

to do
\begin_inset Quotes erd
\end_inset

 list).
\end_layout

\begin_layout Itemize
Floating point constants.
\end_layout

\begin_layout Itemize
Characters denoted with the syntax 'X' where X is any valid ASCII character.
\end_layout

\begin_layout Itemize
C-like strings: 
\begin_inset Quotes eld
\end_inset

this is a string
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
How 
\emph on
jit-testing
\emph default
 will treat each value is shown the following code snippets in comments.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		# It will take the ASCII value of 'a' (49)
\end_layout

\begin_layout Plain Layout

		sum(2,2) == 'a';
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# If sum returns an unsigned value,
\end_layout

\begin_layout Plain Layout

		# -47 will be treated as unsigned value
\end_layout

\begin_layout Plain Layout

		sum(2,2) == -47;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# It will take the memory address of the
\end_layout

\begin_layout Plain Layout

		# string and casting it to whatever data
\end_layout

\begin_layout Plain Layout

		# type the function returns
\end_layout

\begin_layout Plain Layout

		sum(2,2) == "this is a string";		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In all cases the tool will cast the expected value to whatever data type
 the function under test returns and then perform the comparison.
 The expected value is ignored for functions that return 'void'.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
To wrap up and use all you have learned in this section try writing a function
 that calculates the factorial of a number using both a recursive and iterative
 solution.
 
\end_layout

\begin_layout Standard
Today is your lucky as I will provide those functions for you :)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		int fact_1(int a) {   
\end_layout

\begin_layout Plain Layout

			if(1 == a) return a;   
\end_layout

\begin_layout Plain Layout

			return a * factorial(a-1); 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		int fact_2(int a) {   
\end_layout

\begin_layout Plain Layout

			unsigned i = 1;   
\end_layout

\begin_layout Plain Layout

			while(a) i *= a--;   
\end_layout

\begin_layout Plain Layout

			return i; 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Try writing your own versions of these two functions and test them all using
 
\emph on
jit-testing
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Managing program state
\begin_inset CommandInset label
LatexCommand label
name "sub:Managing-program-state"

\end_inset


\end_layout

\begin_layout Standard
Any non-trivial program will contain its own state represented as a set
 of data structures which are modified by a series of function calls.
 Sometimes a given function behavior depends not only on the parameter values
 it receives but also on the current value of one or several global variables
 or structures.
\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 lets you define the state of your program by using 2 keywords from the
 
\emph on
jit-testing language: 
\family typewriter
\emph default
before
\family default
\emph on
 
\emph default
and
\emph on
 
\family typewriter
\emph default
after.
\end_layout

\begin_layout Standard
The syntax for these two keywords is as follow:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		[before { ...
 }]
\end_layout

\begin_layout Plain Layout

		function_under_test();
\end_layout

\begin_layout Plain Layout

		[after { ...
 }]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You have to write the 
\emph on
before 
\emph default
keyword before the function you want to test and type the 
\emph on
after
\emph default
 keyword after the function you want to test.
 The curly braces are mandatory for both the 
\emph on
before
\emph default
 and 
\emph on
after
\emph default
 keywords.
 The squared brackets indicate that either statement are optional for your
 test.
\end_layout

\begin_layout Standard
The important thing to note here is that any statement you specify inside
 the curly brace 
\series bold
will be executed 
\emph on
before
\emph default
 and 
\emph on
after
\series default
 
\emph default
the function under test respectively.
 You can have 3 different of statements inside the curly braces and they
 are described with the following examples.
\end_layout

\begin_layout Subsubsection
Modifying global variables
\end_layout

\begin_layout Standard
Write the following code in your source file.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		int state; /* Global variable */
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		int get_state() {   
\end_layout

\begin_layout Plain Layout

			return state; 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Write the following test in your test file.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		get_state() == 0;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Run this test through the command line.
 Remember that the C standard specificies that global variables will be
 initialized to 0, thus our test succeeds and 
\emph on
jit-testing
\emph default
 will report the actual result.
\end_layout

\begin_layout Standard
Now try writing the following test:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		before { state = 10; } # Assignment operator =
\end_layout

\begin_layout Plain Layout

		get_state() == 0; 	 # Comparison operator ==
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Try running this test and you will see that it fails.
 The reason why it fails is because 
\emph on
jit-testing
\emph default
 modified the variable 
\emph on
state
\emph default
 and assigned a 
\emph on
10
\emph default
 to it right before executing the function 
\emph on
get_state()
\emph default
.
 Thus the actual result from calling 
\emph on
get_state()
\emph default
 is 10.
\end_layout

\begin_layout Subsubsection
Checking global variables values
\end_layout

\begin_layout Standard
Imagine the 
\emph on
get_state()
\emph default
 function has a return type of 
\emph on
void
\emph default
 and there was no way for us to check which value the variable 
\emph on
state
\emph default
 has after calling the function under test.
 This problem can be solved by making a comparison using the 
\emph on
after
\emph default
 keyword.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		before { state = 10; } # Assignment operator =
\end_layout

\begin_layout Plain Layout

		get_state(); 	 # Imagine this function returns 'void'
\end_layout

\begin_layout Plain Layout

		after { state == 10; } # Comparison operator ==
\end_layout

\end_inset

This test will succeed as 
\emph on
jit-testing
\emph default
 will check that the variable 
\emph on
state
\emph default
 has a value of 
\emph on
10 after
\emph default
 running the function under test.
 Note that when there is no expected value specified after function under
 test the return value is ignored regardless of its data type.
\end_layout

\begin_layout Subsubsection
Calling functions
\series medium
 
\series default
\emph on
before
\emph default
 and 
\emph on
after
\emph default
 a function under test
\begin_inset CommandInset label
LatexCommand label
name "sub:Calling-functions-before"

\end_inset


\end_layout

\begin_layout Standard
Now add the following function to your C source file 
\emph on
some_file.c
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		void modify_state() {   
\end_layout

\begin_layout Plain Layout

			state += 5; 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we will modify the variable 
\emph on
state
\emph default
 by calling a function rather than doing an assignment.
 Here is the new test:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		before { modify_state(); } # Function call, state == 5
\end_layout

\begin_layout Plain Layout

		get_state() == 5; # Passes
\end_layout

\begin_layout Plain Layout

		after { modify_state(); } # You can call a function call here to, state
 == 10
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This test will succed because the function 
\emph on
modify_state()
\emph default
 is called before the 
\emph on
get_state()
\emph default
 function modifying the global variable.
 In the 
\family typewriter
after
\family default
 statement we also call the function that modifies the global variable.
 Calling this function for this toy example is useless, but you can think
 of calling a function that cleans up all the things done in the 
\family typewriter
before
\family default
 statement or during the function under test.
\end_layout

\begin_layout Standard
NOTE: There is one important thing to note here.
 
\emph on
jit-testing 
\emph default
will backup any global variable you modify in the 
\family typewriter
after
\family default
 or 
\family typewriter
before
\family default
 statements and then restore their original value right before starting
 executing the next.
 Thus leaving the program state in its original value before starting execution
 of the current.
 However, 
\emph on
jit-testing
\emph default
 will not detect when a function called in the after or before statements
 has modified a global variable, thus the modified variables will remain
 with this new value for the next test that is run.
 If you call any 
\emph on
setup
\emph default
 function in the 
\family typewriter
before
\family default
 statement, make sure you call a 
\emph on
cleanup
\emph default
 function in the 
\family typewriter
after
\family default
 statement to leave the program state in an optimal state in which other
 tests can be run.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
In this section we just learned that we can use the 
\emph on
before
\emph default
 and 
\emph on
after
\emph default
 keywords to execute three different types of statements:
\end_layout

\begin_layout Enumerate
Variable assignment 'variable = X' where X is any value as described in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expected-results"

\end_inset

.
\end_layout

\begin_layout Enumerate
Function call.
\end_layout

\begin_layout Enumerate
Variable comparison with any value as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Expected-results"

\end_inset

.
\end_layout

\begin_layout Standard
The syntax for the before
\emph on
 
\emph default
and
\emph on
 after 
\emph default
keywords is as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		[before {<variable assignment>* | <function call>* | <variable comparison>*}]
\end_layout

\begin_layout Plain Layout

		function_under_test();
\end_layout

\begin_layout Plain Layout

		[after { <variable assignment>* | <function call>* | <variable comparison>*
 }]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the little star to the right of each statement.
 That indicates that you can have as many statements as you want in the
 
\emph on
before
\emph default
 and 
\emph on
after 
\emph default
statements or none of them.
 The squared bracket indicate that both the before and after statements
 are optional for a function under test.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Grouping related tests
\begin_inset CommandInset label
LatexCommand label
name "sub:Grouping-related-tests"

\end_inset


\end_layout

\begin_layout Standard
Any non-trivial program will have its set of tests, and often times the
 amount such tests will be big.
 A common practice to maintain a set of tests in the long term is to group
 the tests into related sets of tests that comply with a certain criteria.
\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 lets you group any amount of tests by using the keyword 
\family typewriter
group
\family default
.
 The syntax is as follow:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		group [Name] {
\end_layout

\begin_layout Plain Layout

			...
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can optionally provide a name for a given group.
\end_layout

\begin_layout Standard
The reason to have groups is mainly to 2 things: 
\end_layout

\begin_layout Enumerate
Provide a program state for a set of tests in order to avoid having redundant
\emph on
 before
\emph default
 and 
\emph on
after 
\emph default
statements for the same set of tests.
\end_layout

\begin_layout Enumerate
Provide a way to filter and customize the reports by set of tests.
\end_layout

\begin_layout Subsubsection
The default group
\end_layout

\begin_layout Standard
Taking all the examples we've done in the previous section you should have
 the 
\emph on
test_file.jtl
\emph default
 that looks somewhat like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		# test_file.jtl
\end_layout

\begin_layout Plain Layout

		my_function(); 
\end_layout

\begin_layout Plain Layout

		sum(2,2);
\end_layout

\begin_layout Plain Layout

		sum(2,2) == 4; 
\end_layout

\begin_layout Plain Layout

		sum(2,2) != 5; 
\end_layout

\begin_layout Plain Layout

		fact_1(3) == 6;
\end_layout

\begin_layout Plain Layout

		fact_2(3) == 6;
\end_layout

\begin_layout Plain Layout

		get_state() == 0;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By default 
\emph on
jit-testing
\emph default
 adds all the tests in a test file into the 'default group' which is named
 
\emph on
group_0
\emph default
.
 This is merely for implementation convenience and you will see in the test
 reports a 'group_0' for every test you run.
\end_layout

\begin_layout Subsubsection
Nesting groups
\end_layout

\begin_layout Standard
Let us take some of the tests from the 
\emph on
test_file.jtl
\emph default
 and group them into nested groups.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		# test_file.jtl
\end_layout

\begin_layout Plain Layout

		my_function(); 
\end_layout

\begin_layout Plain Layout

		group A {
\end_layout

\begin_layout Plain Layout

			sum(2,2);
\end_layout

\begin_layout Plain Layout

			group B {
\end_layout

\begin_layout Plain Layout

				sum(2,2) == 4;	 
\end_layout

\begin_layout Plain Layout

				group C {
\end_layout

\begin_layout Plain Layout

					sum(2,2) != 5;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		group D {
\end_layout

\begin_layout Plain Layout

			fact_1(3) == 6;
\end_layout

\begin_layout Plain Layout

			fact_2(3) == 6;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		get_state() == 0;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inside a group you can have any number of tests or even any number of nested
 groups.
 There is no limit in how many groups can be nested.
 The tests and groups found within another group will be executed in the
 same order they appear in your test file.
\end_layout

\begin_layout Subsubsection
Managing program states for a given group
\end_layout

\begin_layout Standard
Recall section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Managing-program-state"

\end_inset

 in which we learned how to modify the program state for a given test with
 the keywords 
\family typewriter
before
\family default
 and 
\family typewriter
after
\family default
.
 We can also modify and check the program state for a 
\emph on
group
\emph default
 of tests using the same 
\family typewriter
before
\family default
 and 
\family typewriter
after
\family default
 keywords.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		group [Name] {
\end_layout

\begin_layout Plain Layout

			[before_all { ...
 }]
\end_layout

\begin_layout Plain Layout

			[after_all { ...
 }]
\end_layout

\begin_layout Plain Layout

			...
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These two keywords will modify the program state for the current group they
 belong to, just like we saw in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Managing-program-state"

\end_inset

 they modify the state for a given test this time it applies to the current
 group.
 
\end_layout

\begin_layout Standard
For instance the following examples are valid tests.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		group E { 	 	
\end_layout

\begin_layout Plain Layout

			before_all { state = 10; } # Executed before all the tests in this group
\end_layout

\begin_layout Plain Layout

			after_all  { state == 20; } # Executed after all the tests in this group
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			get_state() == 10; # test 1
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			# jit-testing does not track what's changed inside this function call
\end_layout

\begin_layout Plain Layout

			before { modify_state(); }
\end_layout

\begin_layout Plain Layout

			get_state() == 15; #test 2
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

			modify_state(); # test 3
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		 
\end_layout

\begin_layout Plain Layout

		group F {
\end_layout

\begin_layout Plain Layout

			before_all { state = 5; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			get_state() == 5; 
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			before { modify_state(); } 	
\end_layout

\begin_layout Plain Layout

			get_state() == 10; 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		group G { 	
\end_layout

\begin_layout Plain Layout

			after_all { modify_state(); }
\end_layout

\begin_layout Plain Layout

			get_state() == 0;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All these are valid tests and they all pass.
 Try running writing these tests in your file 
\emph on
test_file.jtl.
 
\emph default
If you have any doubt regarding the results of these tests and when the
 global variables are modified please refer to the note in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Calling-functions-before"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
In this section we learned how to group tests by using the keyword 
\family typewriter
group
\family default
.
 We also learned how to modify the prorgam state for a specific group by
 using the keywords 
\family typewriter
before_all
\family default
 and 
\family typewriter
after_all
\family default
.
 The final syntax for the 
\family typewriter
group
\family default
 keyword is as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

group [Name] {
\end_layout

\begin_layout Plain Layout

	[before_all { <variable assignment>* | <function call>* | <variable comparison>
* }]
\end_layout

\begin_layout Plain Layout

	[after_all  { <variable assignment>* | <function call>* | <variable comparison>
* }]
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Both the 
\family typewriter
before_all
\family default
 and 
\family typewriter
after_all
\family default
 statements are optional for a given group, and they can contain any number
 of variable assignments, function calls or variable comparisons with an
 expected value.
 Note the order in which you can define the 
\family typewriter
before_all
\family default
 and 
\family typewriter
after_all
\family default
 statements, they need to defined after the left curly bracket after the
 
\family typewriter
group
\family default
 keyword.
 A group can also have an optional name.
 If you omit this name the tool will assign this group an automatically
 generated group name.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Structures as global variables
\end_layout

\begin_layout Standard
If you are using a structure as a global variable to keep track of your
 program state you can assign any value to it just like any other global
 variable.
 The only difference is that you have to use C89 struct initialization list
 syntax to initialize the values of your struct.
 Here is an example of such syntax.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		struct Pair {
\end_layout

\begin_layout Plain Layout

			int a;
\end_layout

\begin_layout Plain Layout

			int b;
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

		struct Pair my_pair = { 10, 20 }; // a==10, b==20
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The important thing here is that you have to provide a valid initialization
 value for the variable types in the same order as they declared.
 If you omit an initialization value it has to be for the variables declared
 at the end of the struct.
 Any variable which is not given an initiazilation value using this syntax
 will be initialized to 0.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		struct Pair my_pair = {10}; // a==10, b==0
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Struct initialization list
\begin_inset CommandInset label
LatexCommand label
name "sub:Struct-initialization-list"

\end_inset


\end_layout

\begin_layout Standard
Let us write a funciton that prints the contents of a global struct.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Testing-code-which"

\end_inset

 on how to use the C standard library.
 Open your 
\emph on
some_file.c
\emph default
 and type the following.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		/** some_file.c **/
\end_layout

\begin_layout Plain Layout

		#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		struct Pair { 	
\end_layout

\begin_layout Plain Layout

			int a; 	
\end_layout

\begin_layout Plain Layout

			int b; 
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		struct NestedPair { 	
\end_layout

\begin_layout Plain Layout

			int a; 	
\end_layout

\begin_layout Plain Layout

			int b; 	
\end_layout

\begin_layout Plain Layout

			struct Pair nested; 
\end_layout

\begin_layout Plain Layout

		};
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		struct NestedPair global_pair;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		void print_global_pair(){
\end_layout

\begin_layout Plain Layout

			printf("global_pair.a = %d
\backslash
n", global_pair.a); 	
\end_layout

\begin_layout Plain Layout

			printf("global_pair.b = %d
\backslash
n", global_pair.a); 	
\end_layout

\begin_layout Plain Layout

			printf("global_pair.subpair.a = %d
\backslash
n", global_pair.nested.a); 	
\end_layout

\begin_layout Plain Layout

			printf("global_pair.subpair.b = %d
\backslash
n", global_pair.nested.b); 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now write the following tests in your 
\emph on
test_file.jtl
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		# test 1 
\end_layout

\begin_layout Plain Layout

		print_global_pair();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# test 2 
\end_layout

\begin_layout Plain Layout

		before {global_pair = {1}; } 
\end_layout

\begin_layout Plain Layout

		print_global_pair();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# test 3 
\end_layout

\begin_layout Plain Layout

		before {global_pair = {1,2}; } 
\end_layout

\begin_layout Plain Layout

		print_global_pair();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# test 4 
\end_layout

\begin_layout Plain Layout

		before {global_pair = {1,2, {5} }; } 
\end_layout

\begin_layout Plain Layout

		print_global_pair();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		# test 5 
\end_layout

\begin_layout Plain Layout

		before {global_pair = {1,2, {5,6} }; } 
\end_layout

\begin_layout Plain Layout

		print_global_pair();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These 5 tests show the basics of C struct initialization list syntax in
 
\emph on
jit-testing
\emph default
.
 The first test will print the contents of the global struct 
\family typewriter
global_pair
\family default
.
 On the following tests we just modify the contents of such struct one element
 at a time to appreciate how the struct initialization works, even for nested
 structs.
 Note that you cannot assign values starting from the last element in the
 struct, it hast to start from the first element.
\end_layout

\begin_layout Subsubsection
Pointers to structs
\end_layout

\begin_layout Standard
The initialization of structs through a pointer is pretty much the same
 as we just saw.
 However we need to explain how 
\emph on
jit-testing
\emph default
 works with pointers.
 We will explain that and also initializing structs with poitners in the
 next section.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
In this section we learned how can initialize struct wiht the struct initializat
ion list syntax.
 We have to initialize the struct fields in the same order they were declared.
 If we omit a struct field has to be one that was las declared in the struct.
 We can also initialize structs that contain more structs.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pointers
\end_layout

\begin_layout Standard
As C programmer you already know the importance of pointers and how the
 design of functions revolves around the usage of pointers.
 Many functions that take a pointer to any data type assume that the memory
 for that data type was already allocated somwhere else in the code.
 This poses a problem for testing functions that make use of pointers.
 
\emph on
jit-testing 
\emph default
solves this problem by providing a simple syntax to allocate memory for
 a given function.
\end_layout

\begin_layout Subsubsection
Automatic memory allocation
\begin_inset CommandInset label
LatexCommand label
name "sub:Automatic-memory-allocation"

\end_inset


\end_layout

\begin_layout Standard
Whenever you have a function that takes a pointer or a global variable of
 any pointer type, you can tell 
\emph on
jit-testing
\emph default
 to allocate memory for it by using the following syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		[n]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using the squared brackets and putting inside a non-negative integer value
 will make 
\emph on
jit-testing 
\emph default
to allocate the necessary bytes for the data type the pointer points to.
 That is it allocates 
\family typewriter
n*sizeof(<data type>
\family default
) bytes.
 Let us write an example.
 Write the following C code in your file 
\emph on
some_file.c
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		int * g_ptr = NULL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		void print_g_ptr(){
\end_layout

\begin_layout Plain Layout

			if(g_ptr) 		
\end_layout

\begin_layout Plain Layout

				printf("address: %p, contents: %d
\backslash
n",g_ptr,*g_ptr); 	
\end_layout

\begin_layout Plain Layout

			else 		
\end_layout

\begin_layout Plain Layout

				printf("ERROR g_ptr is NULL pointer!
\backslash
n");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then write a simple test in your test file 
\emph on
test_file.jtl.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			print_g_ptr();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After running this test you should see that your test printed the error
 stating 
\emph on
g_ptr
\emph default
 is a null pointer.
 In order to have a working test we can tell 
\emph on
jit-testing 
\emph default
to allocate memory for the data type pointed to by the pointer.
 Let's do it by writting a new test:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			# allocates enough memory for 1 data type g_ptr points to.
\end_layout

\begin_layout Plain Layout

			before { g_ptr = [1]; }
\end_layout

\begin_layout Plain Layout

			print_g_ptr();
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
jit-testing 
\emph default
will allocate enough memory for 
\emph on
1 integer
\emph default
 because the data type g_ptr points to is an integer.
 If the pointer was a pointer to a char, short integer, or even a struct
 type, 
\emph on
jit-testing
\emph default
 will allocate enough memory for that data type.
 
\end_layout

\begin_layout Standard
This means that could allocate enough memory for an array of integers by
 writing the following test.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			# allocates enough memory for 1024 data type g_ptr points to.
\end_layout

\begin_layout Plain Layout

			before { g_ptr = [1024]; } 
\end_layout

\begin_layout Plain Layout

			print_g_ptr();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course the function print_g_ptr() only accesses the first element in
 the array, but still 
\emph on
jit-testing
\emph default
 allocates enough memory to fit 1024 integers.
\end_layout

\begin_layout Standard
You don't have to worry about 
\emph on
free
\emph default
ing the memory allocated, 
\emph on
jit-testing 
\emph default
will do that for you automatically after running this test.
 If you want the memory allocated to last for the execution of several tests
 you may want put the expression 
\family typewriter
g_ptr = [n]
\family default
 in a 
\family typewriter
before_all
\family default
 statement.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Grouping-related-tests"

\end_inset

 for more information on 
\family typewriter
group
\family default
s.
\end_layout

\begin_layout Subsubsection
Memory initialization
\begin_inset CommandInset label
LatexCommand label
name "sub:Memory-initialization"

\end_inset


\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 provides an easy way to initialize all the memory allocated for a pointer
 by using the following syntax:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			[n:x]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We just add a colon and then we pass an non-negative integer value 
\emph on
'x'
\emph default
 to indicate an initialization value to be stored in every 
\series bold
byte
\series default
 of memory allocated for the given pointer.
 Rewrite the test from previous exercise to initialize the memory:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			# allocates enough memory for 1 data type g_ptr points to.
\end_layout

\begin_layout Plain Layout

			before { g_ptr = [1:5]; } 
\end_layout

\begin_layout Plain Layout

			print_g_ptr();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After running the test you will see that the contents of the memory allocated
 is actually a 
\emph on
5
\emph default
.
\end_layout

\begin_layout Standard
To wrap up this exercise write down the following C function in your file
 
\emph on
some_file.c:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		// Print the contents of the array pointed to by buf
\end_layout

\begin_layout Plain Layout

		void print_buffer(unsigned char *buf, unsigned size) { 	
\end_layout

\begin_layout Plain Layout

			short step = 1; 	
\end_layout

\begin_layout Plain Layout

			unsigned char *i = buf; 	
\end_layout

\begin_layout Plain Layout

			unsigned char *end = buf + size;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			while(i < end) { 		
\end_layout

\begin_layout Plain Layout

				printf("%x ", *i); 		
\end_layout

\begin_layout Plain Layout

				if(step%10 == 0) 			
\end_layout

\begin_layout Plain Layout

				printf("
\backslash
n"); 		
\end_layout

\begin_layout Plain Layout

				++step; 		
\end_layout

\begin_layout Plain Layout

				++i; 	
\end_layout

\begin_layout Plain Layout

			} 	
\end_layout

\begin_layout Plain Layout

			printf("
\backslash
n"); 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And write the following test in your file 
\emph on
test_file.jtl 
\emph default
and then run it
\emph on
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		print_buffer([20:6], 20);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
print_buffer
\family default
 will print 
\family typewriter
size
\family default
 bytes of the array pointed to by 
\family typewriter
buf
\family default
.
 We just tested this function with 
\emph on
jit-testing
\emph default
 by allocating 20 elements of type 
\family typewriter
unsigned char
\family default
 and passing that pointer to the function.
 Then we passed the size of the array which is 20 (rememeber the size of
 an unsigned char is 1 byte).
 After running that function you will see printed on screen the contents
 of the array which is 6.
\end_layout

\begin_layout Subsubsection
Pointers to structures
\end_layout

\begin_layout Standard
If you had a global variable which is a pointer to a struct or a function
 that receives a pointer to a struct the section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Automatic-memory-allocation"

\end_inset

 and section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Memory-initialization"

\end_inset

 applies the same to pointer to structs.
 If you'd like to initialize each field of the struct just as described
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Struct-initialization-list"

\end_inset

 the only thing you need to change is the initialization value to a struct
 initialization list.
 The following example demonstrates this.
 Write this function in your file 
\emph on
some_file.c
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		// some_file.c
\end_layout

\begin_layout Plain Layout

		void print_ptr_pair(struct NestedPair* ptr) { 	
\end_layout

\begin_layout Plain Layout

			if(ptr) { 		
\end_layout

\begin_layout Plain Layout

				printf("ptr.a = %d
\backslash
n", ptr->a); 		
\end_layout

\begin_layout Plain Layout

				printf("ptr.b = %d
\backslash
n", ptr->b); 		
\end_layout

\begin_layout Plain Layout

				printf("ptr.subpair.a = %d
\backslash
n", ptr->nested.a); 		
\end_layout

\begin_layout Plain Layout

				printf("ptr.subpair.b = %d
\backslash
n", ptr->nested.b); 	
\end_layout

\begin_layout Plain Layout

			} else 		
\end_layout

\begin_layout Plain Layout

				printf("ERROR ptr is NULL pointer!
\backslash
n"); 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Write the following test:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

		print_ptr_pair([1:{1,2,{3,4}}]);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can see that instead of providing an integer value to initialize the
 memory allocated, we provide a struct initializer as described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Struct-initialization-list"

\end_inset

.
\end_layout

\begin_layout Standard
NOTE: Struct initialization list for global pointers to structs is not yet
 implemented, is still work in progress :)
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
In this section we learned that we can tell 
\emph on
jit-testing 
\emph default
to allocate enough memory for any pointer with the syntax [n:x] which makes
 it allocate 
\family typewriter
n*sizeof(<data type>)
\family default
 bytes and initialize each byte of that allocated memory with the value
 
\family typewriter
x
\family default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Section
Advanced topics
\end_layout

\begin_layout Subsection
Testing code which uses the C standard library.
\begin_inset CommandInset label
LatexCommand label
name "sub:Testing-code-which"

\end_inset


\end_layout

\begin_layout Standard
While writting tests you will find code that uses the C standard library
 stdio.h, stdlib.h, etc.
 and 
\emph on
jit-testing
\emph default
 may complain about not finding the header files for the libraries.
 All you need to do is to provide the command line flag 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			-I path/to/include/files
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For linux users this won't be much of a problem because jit-testing will
 probably find the correct path to the standard library if it was properly
 installed using the proper package manager or installer.
\end_layout

\begin_layout Standard
For Windows users two small folders will be provided with the 
\emph on
jit-testing 
\emph default
binary include and lib.
 Assuming the binary is on the same folder level as the include and lib
 folder you can execute the tool with the following command:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

			jit-testing -I include some_file.c --test-file test_file.jtl
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testing code which uses a 3rd party library.
\end_layout

\begin_layout Standard
In case the C code you are testing makes use of a 3rd party library you
 will need to tell 
\emph on
jit-testing 
\emph default
where their header and source files are located by using the command lines
 as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Testing-code-which"

\end_inset


\end_layout

\begin_layout Standard
[TODO: Improve this section]
\end_layout

\begin_layout Subsection
Testing code spread in different source files.
\begin_inset CommandInset label
LatexCommand label
name "sub:Testing-code-spread"

\end_inset


\end_layout

\begin_layout Standard

\emph on
jit-testing
\emph default
 only supports processing one source file (.c file) at a time.
 Support for handling multiple source files is being implemented as of now.
\end_layout

\end_body
\end_document
